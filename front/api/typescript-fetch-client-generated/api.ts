/* eslint-disable */
/// <reference path="./custom.d.ts" />
// tslint:disable
// @ts-nocheck
/**
 * ExtranetAPI
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url'
import * as isomorphicFetch from 'isomorphic-fetch'
import {Configuration} from './configuration'

const BASE_PATH = '/'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
	csv: ',',
	ssv: ' ',
	tsv: '\t',
	pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
	(url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
	url: string;
	options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
	protected configuration: Configuration

	constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
		if (configuration) {
			this.configuration = configuration
			this.basePath = configuration.basePath || this.basePath
		}
	}
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
	name: 'RequiredError'

	constructor(public field: string, msg?: string) {
		super(msg)
	}
}

/**
 *
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
	/**
	 *
	 * @type {string}
	 * @memberof AccountDto
	 */
	login?: string;
	/**
	 *
	 * @type {string}
	 * @memberof AccountDto
	 */
	password?: string;
}

/**
 *
 * @export
 * @interface BuisnessCost
 */
export interface BuisnessCost {
	/**
	 *
	 * @type {number}
	 * @memberof BuisnessCost
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof BuisnessCost
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof BuisnessCost
	 */
	amount?: number;
	/**
	 *
	 * @type {Date}
	 * @memberof BuisnessCost
	 */
	date?: string;
}

/**
 *
 * @export
 * @interface ChartDto
 */
export interface ChartDto {
	/**
	 *
	 * @type {Period}
	 * @memberof ChartDto
	 */
	period?: Period;
	/**
	 *
	 * @type {ChartPeriodType}
	 * @memberof ChartDto
	 */
	chartPeriodType?: ChartPeriodType;
	/**
	 *
	 * @type {ChartType}
	 * @memberof ChartDto
	 */
	chartType?: ChartType;
}

/**
 *
 * @export
 * @interface ChartItemDto
 */
export interface ChartItemDto {
	/**
	 *
	 * @type {Date}
	 * @memberof ChartItemDto
	 */
	date?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof ChartItemDto
	 */
	value?: number;
}

/**
 *
 * @export
 * @interface ChartItemWeeksDto
 */
export interface ChartItemWeeksDto {
	/**
	 *
	 * @type {Period}
	 * @memberof ChartItemWeeksDto
	 */
	period?: Period;
	/**
	 *
	 * @type {number}
	 * @memberof ChartItemWeeksDto
	 */
	value?: number;
}

/**
 *
 * @export
 * @enum {string}
 */
export enum ChartPeriodType {
	NUMBER_0 = <any>0,
	NUMBER_1 = <any>1,
	NUMBER_2 = <any>2,
	NUMBER_3 = <any>3
}

/**
 *
 * @export
 * @enum {string}
 */
export enum ChartType {
	NUMBER_0 = <any>0,
	NUMBER_1 = <any>1,
	NUMBER_2 = <any>2,
	NUMBER_3 = <any>3,
	NUMBER_4 = <any>4,
	NUMBER_5 = <any>5,
	NUMBER_6 = <any>6,
	NUMBER_7 = <any>7,
	NUMBER_8 = <any>8,
	NUMBER_9 = <any>9,
	NUMBER_10 = <any>10
}

/**
 *
 * @export
 * @interface ClientDto
 */
export interface ClientDto {
	/**
	 *
	 * @type {number}
	 * @memberof ClientDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	communicationChannel?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	phoneNumber?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	mail?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ClientDto
	 */
	description?: string;
}

/**
 *
 * @export
 * @interface ClientPayment
 */
export interface ClientPayment {
	/**
	 *
	 * @type {Date}
	 * @memberof ClientPayment
	 */
	paymentDate?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof ClientPayment
	 */
	amount?: number;
}

/**
 *
 * @export
 * @interface Cost
 */
export interface Cost {
	/**
	 *
	 * @type {number}
	 * @memberof Cost
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof Cost
	 */
	name?: string;
}

/**
 *
 * @export
 * @interface CostDto
 */
export interface CostDto {
	/**
	 *
	 * @type {string}
	 * @memberof CostDto
	 */
	name?: string;
	/**
	 *
	 * @type {number}
	 * @memberof CostDto
	 */
	amount?: number;
	/**
	 *
	 * @type {number}
	 * @memberof CostDto
	 */
	persent?: number;
}

/**
 *
 * @export
 * @interface CostPayment
 */
export interface CostPayment {
	/**
	 *
	 * @type {number}
	 * @memberof CostPayment
	 */
	costId?: number;
	/**
	 *
	 * @type {Date}
	 * @memberof CostPayment
	 */
	paymentDate?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof CostPayment
	 */
	amount?: number;
}

/**
 *
 * @export
 * @interface CostPriceDto
 */
export interface CostPriceDto {
	/**
	 *
	 * @type {number}
	 * @memberof CostPriceDto
	 */
	costPrice?: number;
	/**
	 *
	 * @type {Array<CostDto>}
	 * @memberof CostPriceDto
	 */
	costs?: Array<CostDto>;
}

/**
 *
 * @export
 * @interface NumericalIndicatorsDto
 */
export interface NumericalIndicatorsDto {
	/**
	 *
	 * @type {number}
	 * @memberof NumericalIndicatorsDto
	 */
	averageCheck?: number;
	/**
	 *
	 * @type {number}
	 * @memberof NumericalIndicatorsDto
	 */
	averageProductionDays?: number;
	/**
	 *
	 * @type {number}
	 * @memberof NumericalIndicatorsDto
	 */
	numberOfProducts?: number;
}

/**
 *
 * @export
 * @interface NumericalPeriodDto
 */
export interface NumericalPeriodDto {
	/**
	 *
	 * @type {Period}
	 * @memberof NumericalPeriodDto
	 */
	period?: Period;
	/**
	 *
	 * @type {ChartPeriodType}
	 * @memberof NumericalPeriodDto
	 */
	chartPeriodType?: ChartPeriodType;
}

/**
 *
 * @export
 * @interface Period
 */
export interface Period {
	/**
	 *
	 * @type {Date}
	 * @memberof Period
	 */
	startDate?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof Period
	 */
	endDate?: string;
}

/**
 *
 * @export
 * @interface ProjectBudgetDto
 */
export interface ProjectBudgetDto {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	id?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	projectId?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectBudgetDto
	 */
	projectCost?: number;
	/**
	 *
	 * @type {Array<ClientPayment>}
	 * @memberof ProjectBudgetDto
	 */
	clientPayments?: Array<ClientPayment>;
	/**
	 *
	 * @type {Array<CostPayment>}
	 * @memberof ProjectBudgetDto
	 */
	costPayments?: Array<CostPayment>;
}

/**
 *
 * @export
 * @interface ProjectDeadlineSettings
 */
export interface ProjectDeadlineSettings {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	id?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	daysForDeadlineYellow?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	daysForDeadlineRed?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDeadlineSettings
	 */
	defaultProjectDurationDays?: number;
}

/**
 *
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	projectType?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	contractNumber?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	dateOfStart?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	dateOfApplication?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	deadLine?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectDto
	 */
	endDate?: string;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectDto
	 */
	clientId?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	address?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectDto
	 */
	description?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProjectDto
	 */
	isCompleted?: boolean;
}

/**
 *
 * @export
 * @interface ProjectStage
 */
export interface ProjectStage {
	/**
	 *
	 * @type {number}
	 * @memberof ProjectStage
	 */
	id?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectStage
	 */
	projectId?: number;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectStage
	 */
	projectStageCode?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectStage
	 */
	name?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectStage
	 */
	description?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectStage
	 */
	completedOn?: Date;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProjectStage
	 */
	isCompleted?: boolean;
}

/**
 *
 * @export
 * @interface ProjectSummaryTableDto
 */
export interface ProjectSummaryTableDto {
	/**
	 *
	 * @type {string}
	 * @memberof ProjectSummaryTableDto
	 */
	contractNumber?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProjectSummaryTableDto
	 */
	projectType?: string;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectSummaryTableDto
	 */
	startDate?: Date;
	/**
	 *
	 * @type {Date}
	 * @memberof ProjectSummaryTableDto
	 */
	endDate?: Date;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectSummaryTableDto
	 */
	numberOfDays?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectSummaryTableDto
	 */
	projectCost?: number;
	/**
	 *
	 * @type {CostPriceDto}
	 * @memberof ProjectSummaryTableDto
	 */
	costPrice?: CostPriceDto;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectSummaryTableDto
	 */
	margin?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectSummaryTableDto
	 */
	profitNorm?: number;
	/**
	 *
	 * @type {number}
	 * @memberof ProjectSummaryTableDto
	 */
	rateOfSurplusValue?: number;
	/**
	 *
	 * @type {Array<StageDto>}
	 * @memberof ProjectSummaryTableDto
	 */
	stages?: Array<StageDto>;
}

/**
 *
 * @export
 * @interface StageDto
 */
export interface StageDto {
	/**
	 *
	 * @type {string}
	 * @memberof StageDto
	 */
	name?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof StageDto
	 */
	isCompleted?: boolean;
}

/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
	/**
	 *
	 * @type {number}
	 * @memberof UserDto
	 */
	id?: number;
	/**
	 *
	 * @type {string}
	 * @memberof UserDto
	 */
	email?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UserDto
	 */
	fullName?: string;
	/**
	 *
	 * @type {string}
	 * @memberof UserDto
	 */
	password?: string;
	/**
	 *
	 * @type {number}
	 * @memberof UserDto
	 */
	role?: number;
}

/**
 * AnalyticsApi - fetch parameter creator
 * @export
 */
export const AnalyticsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить данные для аналитики по дате
		 * @param {ChartDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsDataByDatePost(body?: ChartDto, options: any = {}): FetchArgs {
			const localVarPath = `/analytics/data-by-date`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ChartDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить данные для аналитики по периоду
		 * @param {ChartDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsDataByPeriodPost(body?: ChartDto, options: any = {}): FetchArgs {
			const localVarPath = `/analytics/data-by-period`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ChartDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Числовые показатели за период
		 * @param {NumericalPeriodDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsNumericalIndicatorsPost(body?: NumericalPeriodDto, options: any = {}): FetchArgs {
			const localVarPath = `/analytics/numerical-indicators`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'NumericalPeriodDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить данные для аналитики по дате
		 * @param {ChartDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsDataByDatePost(body?: ChartDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChartItemDto>> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsDataByDatePost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить данные для аналитики по периоду
		 * @param {ChartDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsDataByPeriodPost(body?: ChartDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChartItemWeeksDto>> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsDataByPeriodPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Числовые показатели за период
		 * @param {NumericalPeriodDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsNumericalIndicatorsPost(body?: NumericalPeriodDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumericalIndicatorsDto> {
			const localVarFetchArgs = AnalyticsApiFetchParamCreator(configuration).analyticsNumericalIndicatorsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить данные для аналитики по дате
		 * @param {ChartDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsDataByDatePost(body?: ChartDto, options?: any) {
			return AnalyticsApiFp(configuration).analyticsDataByDatePost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить данные для аналитики по периоду
		 * @param {ChartDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsDataByPeriodPost(body?: ChartDto, options?: any) {
			return AnalyticsApiFp(configuration).analyticsDataByPeriodPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Числовые показатели за период
		 * @param {NumericalPeriodDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyticsNumericalIndicatorsPost(body?: NumericalPeriodDto, options?: any) {
			return AnalyticsApiFp(configuration).analyticsNumericalIndicatorsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
	/**
	 *
	 * @summary Получить данные для аналитики по дате
	 * @param {ChartDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsDataByDatePost(body?: ChartDto, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsDataByDatePost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить данные для аналитики по периоду
	 * @param {ChartDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsDataByPeriodPost(body?: ChartDto, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsDataByPeriodPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Числовые показатели за период
	 * @param {NumericalPeriodDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AnalyticsApi
	 */
	public analyticsNumericalIndicatorsPost(body?: NumericalPeriodDto, options?: any) {
		return AnalyticsApiFp(this.configuration).analyticsNumericalIndicatorsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * AuthentificationApi - fetch parameter creator
 * @export
 */
export const AuthentificationApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Логинация пользователя
		 * @param {AccountDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authentificationPost(body?: AccountDto, options: any = {}): FetchArgs {
			const localVarPath = `/authentification`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'AccountDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Выход пользователя
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logoutPost(options: any = {}): FetchArgs {
			const localVarPath = `/logout`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AuthentificationApi - functional programming interface
 * @export
 */
export const AuthentificationApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Логинация пользователя
		 * @param {AccountDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authentificationPost(body?: AccountDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = AuthentificationApiFetchParamCreator(configuration).authentificationPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Выход пользователя
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logoutPost(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = AuthentificationApiFetchParamCreator(configuration).logoutPost(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * AuthentificationApi - factory interface
 * @export
 */
export const AuthentificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Логинация пользователя
		 * @param {AccountDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		authentificationPost(body?: AccountDto, options?: any) {
			return AuthentificationApiFp(configuration).authentificationPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Выход пользователя
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logoutPost(options?: any) {
			return AuthentificationApiFp(configuration).logoutPost(options)(fetch, basePath)
		},
	}
}

/**
 * AuthentificationApi - object-oriented interface
 * @export
 * @class AuthentificationApi
 * @extends {BaseAPI}
 */
export class AuthentificationApi extends BaseAPI {
	/**
	 *
	 * @summary Логинация пользователя
	 * @param {AccountDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthentificationApi
	 */
	public authentificationPost(body?: AccountDto, options?: any) {
		return AuthentificationApiFp(this.configuration).authentificationPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Выход пользователя
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthentificationApi
	 */
	public logoutPost(options?: any) {
		return AuthentificationApiFp(this.configuration).logoutPost(options)(this.fetch, this.basePath)
	}

}

/**
 * BuisnessCostApi - fetch parameter creator
 * @export
 */
export const BuisnessCostApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsCostIdCostUpdatingPost(body: BuisnessCost, costId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling buisnessCostsCostIdCostUpdatingPost.')
			}
			// verify required parameter 'costId' is not null or undefined
			if (costId === null || costId === undefined) {
				throw new RequiredError('costId', 'Required parameter costId was null or undefined when calling buisnessCostsCostIdCostUpdatingPost.')
			}
			const localVarPath = `/buisness-costs/{costId}/cost-updating`
				.replace(`{${'costId'}}`, encodeURIComponent(String(costId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'BuisnessCost' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить все бизнесовые издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsGet(options: any = {}): FetchArgs {
			const localVarPath = `/buisness-costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить бизнесовую издержку
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsIdDelete(id: number, options: any = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling buisnessCostsIdDelete.')
			}
			const localVarPath = `/buisness-costs/{id}`
				.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsPost(body: BuisnessCost, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling buisnessCostsPost.')
			}
			const localVarPath = `/buisness-costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'BuisnessCost' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * BuisnessCostApi - functional programming interface
 * @export
 */
export const BuisnessCostApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsCostIdCostUpdatingPost(body: BuisnessCost, costId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = BuisnessCostApiFetchParamCreator(configuration).buisnessCostsCostIdCostUpdatingPost(body, costId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить все бизнесовые издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BuisnessCost>> {
			const localVarFetchArgs = BuisnessCostApiFetchParamCreator(configuration).buisnessCostsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить бизнесовую издержку
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = BuisnessCostApiFetchParamCreator(configuration).buisnessCostsIdDelete(id, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsPost(body: BuisnessCost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = BuisnessCostApiFetchParamCreator(configuration).buisnessCostsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * BuisnessCostApi - factory interface
 * @export
 */
export const BuisnessCostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Обновить бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsCostIdCostUpdatingPost(body: BuisnessCost, costId: number, options?: any) {
			return BuisnessCostApiFp(configuration).buisnessCostsCostIdCostUpdatingPost(body, costId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить все бизнесовые издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsGet(options?: any) {
			return BuisnessCostApiFp(configuration).buisnessCostsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить бизнесовую издержку
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsIdDelete(id: number, options?: any) {
			return BuisnessCostApiFp(configuration).buisnessCostsIdDelete(id, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать бизнесовую издержку
		 * @param {BuisnessCost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		buisnessCostsPost(body: BuisnessCost, options?: any) {
			return BuisnessCostApiFp(configuration).buisnessCostsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * BuisnessCostApi - object-oriented interface
 * @export
 * @class BuisnessCostApi
 * @extends {BaseAPI}
 */
export class BuisnessCostApi extends BaseAPI {
	/**
	 *
	 * @summary Обновить бизнесовую издержку
	 * @param {BuisnessCost} body
	 * @param {number} costId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BuisnessCostApi
	 */
	public buisnessCostsCostIdCostUpdatingPost(body: BuisnessCost, costId: number, options?: any) {
		return BuisnessCostApiFp(this.configuration).buisnessCostsCostIdCostUpdatingPost(body, costId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить все бизнесовые издержки
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BuisnessCostApi
	 */
	public buisnessCostsGet(options?: any) {
		return BuisnessCostApiFp(this.configuration).buisnessCostsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить бизнесовую издержку
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BuisnessCostApi
	 */
	public buisnessCostsIdDelete(id: number, options?: any) {
		return BuisnessCostApiFp(this.configuration).buisnessCostsIdDelete(id, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать бизнесовую издержку
	 * @param {BuisnessCost} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BuisnessCostApi
	 */
	public buisnessCostsPost(body: BuisnessCost, options?: any) {
		return BuisnessCostApiFp(this.configuration).buisnessCostsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * ClientApi - fetch parameter creator
 * @export
 */
export const ClientApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling clientsClientIdClientUpdatingPost.')
			}
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdClientUpdatingPost.')
			}
			const localVarPath = `/clients/{clientId}/client-updating`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ClientDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdDelete.')
			}
			const localVarPath = `/clients/{clientId}`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options: any = {}): FetchArgs {
			// verify required parameter 'clientId' is not null or undefined
			if (clientId === null || clientId === undefined) {
				throw new RequiredError('clientId', 'Required parameter clientId was null or undefined when calling clientsClientIdGet.')
			}
			const localVarPath = `/clients/{clientId}`
				.replace(`{${'clientId'}}`, encodeURIComponent(String(clientId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options: any = {}): FetchArgs {
			const localVarPath = `/clients`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling clientsPost.')
			}
			const localVarPath = `/clients`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ClientDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdClientUpdatingPost(body, clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdDelete(clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientDto> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsClientIdGet(clientId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClientDto>> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ClientApiFetchParamCreator(configuration).clientsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Обновить основную информацию по клиенту
		 * @param {ClientDto} body
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdClientUpdatingPost(body, clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить клиента
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdDelete(clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdDelete(clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить клиента по идентификатору
		 * @param {number} clientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsClientIdGet(clientId: number, options?: any) {
			return ClientApiFp(configuration).clientsClientIdGet(clientId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить всех клиентов
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsGet(options?: any) {
			return ClientApiFp(configuration).clientsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать клиента
		 * @param {ClientDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		clientsPost(body: ClientDto, options?: any) {
			return ClientApiFp(configuration).clientsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
	/**
	 *
	 * @summary Обновить основную информацию по клиенту
	 * @param {ClientDto} body
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdClientUpdatingPost(body: ClientDto, clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdClientUpdatingPost(body, clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить клиента
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdDelete(clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdDelete(clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить клиента по идентификатору
	 * @param {number} clientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsClientIdGet(clientId: number, options?: any) {
		return ClientApiFp(this.configuration).clientsClientIdGet(clientId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить всех клиентов
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsGet(options?: any) {
		return ClientApiFp(this.configuration).clientsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать клиента
	 * @param {ClientDto} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ClientApi
	 */
	public clientsPost(body: ClientDto, options?: any) {
		return ClientApiFp(this.configuration).clientsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * CostApi - fetch parameter creator
 * @export
 */
export const CostApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить издержку
		 * @param {Cost} body
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdCostUpdatingPost(body: Cost, costId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling costsCostIdCostUpdatingPost.')
			}
			// verify required parameter 'costId' is not null or undefined
			if (costId === null || costId === undefined) {
				throw new RequiredError('costId', 'Required parameter costId was null or undefined when calling costsCostIdCostUpdatingPost.')
			}
			const localVarPath = `/costs/{costId}/cost-updating`
				.replace(`{${'costId'}}`, encodeURIComponent(String(costId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'Cost' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить издержку
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdDelete(costId: number, options: any = {}): FetchArgs {
			// verify required parameter 'costId' is not null or undefined
			if (costId === null || costId === undefined) {
				throw new RequiredError('costId', 'Required parameter costId was null or undefined when calling costsCostIdDelete.')
			}
			const localVarPath = `/costs/{costId}`
				.replace(`{${'costId'}}`, encodeURIComponent(String(costId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options: any = {}): FetchArgs {
			// verify required parameter 'costId' is not null or undefined
			if (costId === null || costId === undefined) {
				throw new RequiredError('costId', 'Required parameter costId was null or undefined when calling costsCostIdGet.')
			}
			const localVarPath = `/costs/{costId}`
				.replace(`{${'costId'}}`, encodeURIComponent(String(costId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options: any = {}): FetchArgs {
			const localVarPath = `/costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling costsPost.')
			}
			const localVarPath = `/costs`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'Cost' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CostApi - functional programming interface
 * @export
 */
export const CostApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Обновить издержку
		 * @param {Cost} body
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdCostUpdatingPost(body: Cost, costId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsCostIdCostUpdatingPost(body, costId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить издержку
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdDelete(costId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsCostIdDelete(costId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cost> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsCostIdGet(costId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cost>> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = CostApiFetchParamCreator(configuration).costsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * CostApi - factory interface
 * @export
 */
export const CostApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Обновить издержку
		 * @param {Cost} body
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdCostUpdatingPost(body: Cost, costId: number, options?: any) {
			return CostApiFp(configuration).costsCostIdCostUpdatingPost(body, costId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить издержку
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdDelete(costId: number, options?: any) {
			return CostApiFp(configuration).costsCostIdDelete(costId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить издержку по идентификатору
		 * @param {number} costId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsCostIdGet(costId: number, options?: any) {
			return CostApiFp(configuration).costsCostIdGet(costId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить все издержки
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsGet(options?: any) {
			return CostApiFp(configuration).costsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать издержку
		 * @param {Cost} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		costsPost(body: Cost, options?: any) {
			return CostApiFp(configuration).costsPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * CostApi - object-oriented interface
 * @export
 * @class CostApi
 * @extends {BaseAPI}
 */
export class CostApi extends BaseAPI {
	/**
	 *
	 * @summary Обновить издержку
	 * @param {Cost} body
	 * @param {number} costId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsCostIdCostUpdatingPost(body: Cost, costId: number, options?: any) {
		return CostApiFp(this.configuration).costsCostIdCostUpdatingPost(body, costId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить издержку
	 * @param {number} costId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsCostIdDelete(costId: number, options?: any) {
		return CostApiFp(this.configuration).costsCostIdDelete(costId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить издержку по идентификатору
	 * @param {number} costId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsCostIdGet(costId: number, options?: any) {
		return CostApiFp(this.configuration).costsCostIdGet(costId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить все издержки
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsGet(options?: any) {
		return CostApiFp(this.configuration).costsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать издержку
	 * @param {Cost} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CostApi
	 */
	public costsPost(body: Cost, options?: any) {
		return CostApiFp(this.configuration).costsPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options: any = {}): FetchArgs {
			const localVarPath = `/projects`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectsPost.')
			}
			const localVarPath = `/projects`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Завершить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdCompletePost(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdCompletePost.')
			}
			const localVarPath = `/projects/{projectId}/complete`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Установить номер договора
		 * @param {number} projectId
		 * @param {string} contractNumber
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdContractNumberPost(projectId: number, contractNumber: string, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdContractNumberPost.')
			}
			// verify required parameter 'contractNumber' is not null or undefined
			if (contractNumber === null || contractNumber === undefined) {
				throw new RequiredError('contractNumber', 'Required parameter contractNumber was null or undefined when calling projectsProjectIdContractNumberPost.')
			}
			const localVarPath = `/projects/{projectId}/contract-number`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (contractNumber !== undefined) {
				localVarQueryParameter['contractNumber'] = contractNumber
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Установить ожидаемую дату завершения выполнения
		 * @param {number} projectId
		 * @param {Date} deadLine
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDeadlinePost(projectId: number, deadLine: Date, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdDeadlinePost.')
			}
			// verify required parameter 'deadLine' is not null or undefined
			if (deadLine === null || deadLine === undefined) {
				throw new RequiredError('deadLine', 'Required parameter deadLine was null or undefined when calling projectsProjectIdDeadlinePost.')
			}
			const localVarPath = `/projects/{projectId}/deadline`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (deadLine !== undefined) {
				localVarQueryParameter['deadLine'] = (deadLine as any).toISOString()
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdDelete.')
			}
			const localVarPath = `/projects/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Установить актуальную дату завершения выполнения
		 * @param {number} projectId
		 * @param {Date} endDate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdEndDatePost(projectId: number, endDate: Date, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdEndDatePost.')
			}
			// verify required parameter 'endDate' is not null or undefined
			if (endDate === null || endDate === undefined) {
				throw new RequiredError('endDate', 'Required parameter endDate was null or undefined when calling projectsProjectIdEndDatePost.')
			}
			const localVarPath = `/projects/{projectId}/end-date`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (endDate !== undefined) {
				localVarQueryParameter['endDate'] = (endDate as any).toISOString()
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdGet.')
			}
			const localVarPath = `/projects/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectsProjectIdProjectUpdatingPost.')
			}
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdProjectUpdatingPost.')
			}
			const localVarPath = `/projects/{projectId}/project-updating`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Возобновить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdRunPost(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdRunPost.')
			}
			const localVarPath = `/projects/{projectId}/run`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Установить актуальную дату начала выполнения
		 * @param {number} projectId
		 * @param {Date} startDate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStartDatePost(projectId: number, startDate: Date, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdStartDatePost.')
			}
			// verify required parameter 'startDate' is not null or undefined
			if (startDate === null || startDate === undefined) {
				throw new RequiredError('startDate', 'Required parameter startDate was null or undefined when calling projectsProjectIdStartDatePost.')
			}
			const localVarPath = `/projects/{projectId}/start-date`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (startDate !== undefined) {
				localVarQueryParameter['startDate'] = (startDate as any).toISOString()
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Остановить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStopPost(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdStopPost.')
			}
			const localVarPath = `/projects/{projectId}/stop`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить совдую таблицу по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdSummaryTablePost(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectsProjectIdSummaryTablePost.')
			}
			const localVarPath = `/projects/{projectId}/summary-table`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectDto>> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Завершить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdCompletePost(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdCompletePost(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Установить номер договора
		 * @param {number} projectId
		 * @param {string} contractNumber
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdContractNumberPost(projectId: number, contractNumber: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdContractNumberPost(projectId, contractNumber, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Установить ожидаемую дату завершения выполнения
		 * @param {number} projectId
		 * @param {Date} deadLine
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDeadlinePost(projectId: number, deadLine: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdDeadlinePost(projectId, deadLine, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdDelete(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Установить актуальную дату завершения выполнения
		 * @param {number} projectId
		 * @param {Date} endDate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdEndDatePost(projectId: number, endDate: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdEndDatePost(projectId, endDate, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectDto> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Возобновить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdRunPost(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdRunPost(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Установить актуальную дату начала выполнения
		 * @param {number} projectId
		 * @param {Date} startDate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStartDatePost(projectId: number, startDate: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdStartDatePost(projectId, startDate, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Остановить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStopPost(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdStopPost(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить совдую таблицу по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdSummaryTablePost(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectSummaryTableDto> {
			const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).projectsProjectIdSummaryTablePost(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить все проекты
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsGet(options?: any) {
			return ProjectApiFp(configuration).projectsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создать проект
		 * @param {ProjectDto} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsPost(body: ProjectDto, options?: any) {
			return ProjectApiFp(configuration).projectsPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Завершить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdCompletePost(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdCompletePost(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Установить номер договора
		 * @param {number} projectId
		 * @param {string} contractNumber
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdContractNumberPost(projectId: number, contractNumber: string, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdContractNumberPost(projectId, contractNumber, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Установить ожидаемую дату завершения выполнения
		 * @param {number} projectId
		 * @param {Date} deadLine
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDeadlinePost(projectId: number, deadLine: Date, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdDeadlinePost(projectId, deadLine, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Удалить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdDelete(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdDelete(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Установить актуальную дату завершения выполнения
		 * @param {number} projectId
		 * @param {Date} endDate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdEndDatePost(projectId: number, endDate: Date, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdEndDatePost(projectId, endDate, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить проект по идентификатору
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdGet(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить основную информацию по проекту
		 * @param {ProjectDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Возобновить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdRunPost(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdRunPost(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Установить актуальную дату начала выполнения
		 * @param {number} projectId
		 * @param {Date} startDate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStartDatePost(projectId: number, startDate: Date, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdStartDatePost(projectId, startDate, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Остановить проект
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdStopPost(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdStopPost(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить совдую таблицу по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectsProjectIdSummaryTablePost(projectId: number, options?: any) {
			return ProjectApiFp(configuration).projectsProjectIdSummaryTablePost(projectId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
	/**
	 *
	 * @summary Получить все проекты
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsGet(options?: any) {
		return ProjectApiFp(this.configuration).projectsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создать проект
	 * @param {ProjectDto} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsPost(body: ProjectDto, options?: any) {
		return ProjectApiFp(this.configuration).projectsPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Завершить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdCompletePost(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdCompletePost(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Установить номер договора
	 * @param {number} projectId
	 * @param {string} contractNumber
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdContractNumberPost(projectId: number, contractNumber: string, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdContractNumberPost(projectId, contractNumber, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Установить ожидаемую дату завершения выполнения
	 * @param {number} projectId
	 * @param {Date} deadLine
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdDeadlinePost(projectId: number, deadLine: Date, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdDeadlinePost(projectId, deadLine, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Удалить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdDelete(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdDelete(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Установить актуальную дату завершения выполнения
	 * @param {number} projectId
	 * @param {Date} endDate
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdEndDatePost(projectId: number, endDate: Date, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdEndDatePost(projectId, endDate, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить проект по идентификатору
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdGet(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить основную информацию по проекту
	 * @param {ProjectDto} body
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdProjectUpdatingPost(body: ProjectDto, projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdProjectUpdatingPost(body, projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Возобновить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdRunPost(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdRunPost(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Установить актуальную дату начала выполнения
	 * @param {number} projectId
	 * @param {Date} startDate
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdStartDatePost(projectId: number, startDate: Date, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdStartDatePost(projectId, startDate, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Остановить проект
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdStopPost(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdStopPost(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить совдую таблицу по проекту
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectApi
	 */
	public projectsProjectIdSummaryTablePost(projectId: number, options?: any) {
		return ProjectApiFp(this.configuration).projectsProjectIdSummaryTablePost(projectId, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectBudgetApi - fetch parameter creator
 * @export
 */
export const ProjectBudgetApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectBudgetsProjectIdGet.')
			}
			const localVarPath = `/project-budgets/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectBudgetsProjectIdProjectBudgetUpdatingPost.')
			}
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectBudgetsProjectIdProjectBudgetUpdatingPost.')
			}
			const localVarPath = `/project-budgets/{projectId}/project-budget-updating`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectBudgetDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectBudgetApi - functional programming interface
 * @export
 */
export const ProjectBudgetApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectBudgetDto> {
			const localVarFetchArgs = ProjectBudgetApiFetchParamCreator(configuration).projectBudgetsProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectBudgetDto> {
			const localVarFetchArgs = ProjectBudgetApiFetchParamCreator(configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectBudgetApi - factory interface
 * @export
 */
export const ProjectBudgetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить бюджет по проекту
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdGet(projectId: number, options?: any) {
			return ProjectBudgetApiFp(configuration).projectBudgetsProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить бюджет проекта
		 * @param {ProjectBudgetDto} body
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any) {
			return ProjectBudgetApiFp(configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectBudgetApi - object-oriented interface
 * @export
 * @class ProjectBudgetApi
 * @extends {BaseAPI}
 */
export class ProjectBudgetApi extends BaseAPI {
	/**
	 *
	 * @summary Получить бюджет по проекту
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectBudgetApi
	 */
	public projectBudgetsProjectIdGet(projectId: number, options?: any) {
		return ProjectBudgetApiFp(this.configuration).projectBudgetsProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить бюджет проекта
	 * @param {ProjectBudgetDto} body
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectBudgetApi
	 */
	public projectBudgetsProjectIdProjectBudgetUpdatingPost(body: ProjectBudgetDto, projectId: number, options?: any) {
		return ProjectBudgetApiFp(this.configuration).projectBudgetsProjectIdProjectBudgetUpdatingPost(body, projectId, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectDeadlineApi - fetch parameter creator
 * @export
 */
export const ProjectDeadlineApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить текущий дедлайн
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsGet(options: any = {}): FetchArgs {
			const localVarPath = `/project-deadline-settings`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить информацию по дедлайну
		 * @param {ProjectDeadlineSettings} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost.')
			}
			const localVarPath = `/project-deadline-settings/project-deadline-settings-updating`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectDeadlineSettings' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectDeadlineApi - functional programming interface
 * @export
 */
export const ProjectDeadlineApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить текущий дедлайн
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectDeadlineSettings> {
			const localVarFetchArgs = ProjectDeadlineApiFetchParamCreator(configuration).projectDeadlineSettingsGet(options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить информацию по дедлайну
		 * @param {ProjectDeadlineSettings} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectDeadlineApiFetchParamCreator(configuration).projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectDeadlineApi - factory interface
 * @export
 */
export const ProjectDeadlineApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить текущий дедлайн
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsGet(options?: any) {
			return ProjectDeadlineApiFp(configuration).projectDeadlineSettingsGet(options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить информацию по дедлайну
		 * @param {ProjectDeadlineSettings} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options?: any) {
			return ProjectDeadlineApiFp(configuration).projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectDeadlineApi - object-oriented interface
 * @export
 * @class ProjectDeadlineApi
 * @extends {BaseAPI}
 */
export class ProjectDeadlineApi extends BaseAPI {
	/**
	 *
	 * @summary Получить текущий дедлайн
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectDeadlineApi
	 */
	public projectDeadlineSettingsGet(options?: any) {
		return ProjectDeadlineApiFp(this.configuration).projectDeadlineSettingsGet(options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить информацию по дедлайну
	 * @param {ProjectDeadlineSettings} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectDeadlineApi
	 */
	public projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body: ProjectDeadlineSettings, options?: any) {
		return ProjectDeadlineApiFp(this.configuration).projectDeadlineSettingsProjectDeadlineSettingsUpdatingPost(body, options)(this.fetch, this.basePath)
	}

}

/**
 * ProjectStageApi - fetch parameter creator
 * @export
 */
export const ProjectStageApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить текущий этап по проекту  Возвращаем первый следующий после последнего выполненного этапа, если выполненны все, то возваращаем последний
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdCurrentGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectStagesProjectIdCurrentGet.')
			}
			const localVarPath = `/project-stages/{projectId}/current`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получить этапы проекта
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdGet(projectId: number, options: any = {}): FetchArgs {
			// verify required parameter 'projectId' is not null or undefined
			if (projectId === null || projectId === undefined) {
				throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling projectStagesProjectIdGet.')
			}
			const localVarPath = `/project-stages/{projectId}`
				.replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по этапу проекта
		 * @param {ProjectStage} body
		 * @param {number} projectStageId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options: any = {}): FetchArgs {
			// verify required parameter 'body' is not null or undefined
			if (body === null || body === undefined) {
				throw new RequiredError('body', 'Required parameter body was null or undefined when calling projectStagesProjectStageIdProjectStageUpdatingPost.')
			}
			// verify required parameter 'projectStageId' is not null or undefined
			if (projectStageId === null || projectStageId === undefined) {
				throw new RequiredError('projectStageId', 'Required parameter projectStageId was null or undefined when calling projectStagesProjectStageIdProjectStageUpdatingPost.')
			}
			const localVarPath = `/project-stages/{projectStageId}/project-stage-updating`
				.replace(`{${'projectStageId'}}`, encodeURIComponent(String(projectStageId)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'ProjectStage' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProjectStageApi - functional programming interface
 * @export
 */
export const ProjectStageApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Получить текущий этап по проекту  Возвращаем первый следующий после последнего выполненного этапа, если выполненны все, то возваращаем последний
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdCurrentGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectStage> {
			const localVarFetchArgs = ProjectStageApiFetchParamCreator(configuration).projectStagesProjectIdCurrentGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получить этапы проекта
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdGet(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectStage>> {
			const localVarFetchArgs = ProjectStageApiFetchParamCreator(configuration).projectStagesProjectIdGet(projectId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновить основную информацию по этапу проекта
		 * @param {ProjectStage} body
		 * @param {number} projectStageId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = ProjectStageApiFetchParamCreator(configuration).projectStagesProjectStageIdProjectStageUpdatingPost(body, projectStageId, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * ProjectStageApi - factory interface
 * @export
 */
export const ProjectStageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Получить текущий этап по проекту  Возвращаем первый следующий после последнего выполненного этапа, если выполненны все, то возваращаем последний
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdCurrentGet(projectId: number, options?: any) {
			return ProjectStageApiFp(configuration).projectStagesProjectIdCurrentGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получить этапы проекта
		 * @param {number} projectId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectIdGet(projectId: number, options?: any) {
			return ProjectStageApiFp(configuration).projectStagesProjectIdGet(projectId, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновить основную информацию по этапу проекта
		 * @param {ProjectStage} body
		 * @param {number} projectStageId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options?: any) {
			return ProjectStageApiFp(configuration).projectStagesProjectStageIdProjectStageUpdatingPost(body, projectStageId, options)(fetch, basePath)
		},
	}
}

/**
 * ProjectStageApi - object-oriented interface
 * @export
 * @class ProjectStageApi
 * @extends {BaseAPI}
 */
export class ProjectStageApi extends BaseAPI {
	/**
	 *
	 * @summary Получить текущий этап по проекту  Возвращаем первый следующий после последнего выполненного этапа, если выполненны все, то возваращаем последний
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectStageApi
	 */
	public projectStagesProjectIdCurrentGet(projectId: number, options?: any) {
		return ProjectStageApiFp(this.configuration).projectStagesProjectIdCurrentGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получить этапы проекта
	 * @param {number} projectId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectStageApi
	 */
	public projectStagesProjectIdGet(projectId: number, options?: any) {
		return ProjectStageApiFp(this.configuration).projectStagesProjectIdGet(projectId, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновить основную информацию по этапу проекта
	 * @param {ProjectStage} body
	 * @param {number} projectStageId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProjectStageApi
	 */
	public projectStagesProjectStageIdProjectStageUpdatingPost(body: ProjectStage, projectStageId: number, options?: any) {
		return ProjectStageApiFp(this.configuration).projectStagesProjectStageIdProjectStageUpdatingPost(body, projectStageId, options)(this.fetch, this.basePath)
	}

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Удаление пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdDelete(id: number, options: any = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling usersIdDelete.')
			}
			const localVarPath = `/users/{id}`
				.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'DELETE'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Получение пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdGet(id: number, options: any = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling usersIdGet.')
			}
			const localVarPath = `/users/{id}`
				.replace(`{${'id'}}`, encodeURIComponent(String(id)))
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'GET'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Создание пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPost(body?: UserDto, options: any = {}): FetchArgs {
			const localVarPath = `/users`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'UserDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Обновление пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPut(body?: UserDto, options: any = {}): FetchArgs {
			const localVarPath = `/users`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'PUT'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			localVarHeaderParameter['Content-Type'] = 'application/json'

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
			const needsSerialization = (<any>'UserDto' !== 'string') || localVarRequestOptions.headers['Content-Type'] === 'application/json'
			localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || '')

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @summary Поиск пользователей
		 * @param {string} [fullNameSearchPattern]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersSearchPost(fullNameSearchPattern?: string, options: any = {}): FetchArgs {
			const localVarPath = `/users/search`
			const localVarUrlObj = url.parse(localVarPath, true)
			const localVarRequestOptions = Object.assign({method: 'POST'}, options)
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			if (fullNameSearchPattern !== undefined) {
				localVarQueryParameter['fullNameSearchPattern'] = fullNameSearchPattern
			}

			localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query)
			// fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
			delete localVarUrlObj.search
			localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

			return {
				url: url.format(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @summary Удаление пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdDelete(id, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Получение пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdGet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDto> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersIdGet(id, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Создание пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPost(body?: UserDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersPost(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Обновление пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPut(body?: UserDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersPut(body, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.text().then(parseFloat) // приходит число - парсить json не надо
					} else {
						throw response
					}
				})
			}
		},
		/**
		 *
		 * @summary Поиск пользователей
		 * @param {string} [fullNameSearchPattern]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersSearchPost(fullNameSearchPattern?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserDto>> {
			const localVarFetchArgs = UserApiFetchParamCreator(configuration).usersSearchPost(fullNameSearchPattern, options)
			return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					if (response.status >= 200 && response.status < 300) {
						return response.json()
					} else {
						throw response
					}
				})
			}
		},
	}
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
	return {
		/**
		 *
		 * @summary Удаление пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdDelete(id: number, options?: any) {
			return UserApiFp(configuration).usersIdDelete(id, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Получение пользователя
		 * @param {number} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersIdGet(id: number, options?: any) {
			return UserApiFp(configuration).usersIdGet(id, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Создание пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPost(body?: UserDto, options?: any) {
			return UserApiFp(configuration).usersPost(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Обновление пользователя
		 * @param {UserDto} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersPut(body?: UserDto, options?: any) {
			return UserApiFp(configuration).usersPut(body, options)(fetch, basePath)
		},
		/**
		 *
		 * @summary Поиск пользователей
		 * @param {string} [fullNameSearchPattern]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		usersSearchPost(fullNameSearchPattern?: string, options?: any) {
			return UserApiFp(configuration).usersSearchPost(fullNameSearchPattern, options)(fetch, basePath)
		},
	}
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
	/**
	 *
	 * @summary Удаление пользователя
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersIdDelete(id: number, options?: any) {
		return UserApiFp(this.configuration).usersIdDelete(id, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Получение пользователя
	 * @param {number} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersIdGet(id: number, options?: any) {
		return UserApiFp(this.configuration).usersIdGet(id, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Создание пользователя
	 * @param {UserDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersPost(body?: UserDto, options?: any) {
		return UserApiFp(this.configuration).usersPost(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Обновление пользователя
	 * @param {UserDto} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersPut(body?: UserDto, options?: any) {
		return UserApiFp(this.configuration).usersPut(body, options)(this.fetch, this.basePath)
	}

	/**
	 *
	 * @summary Поиск пользователей
	 * @param {string} [fullNameSearchPattern]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public usersSearchPost(fullNameSearchPattern?: string, options?: any) {
		return UserApiFp(this.configuration).usersSearchPost(fullNameSearchPattern, options)(this.fetch, this.basePath)
	}

}
